# 夜莺监控二次开发指南

## 1. 开发环境搭建

### 1.1 环境要求

- **操作系统**: Linux/macOS/Windows
- **Go**: 1.24.0+
- **Node.js**: 16.x+ (建议使用LTS版本)
- **MySQL**: 5.7+ 或 PostgreSQL 9.6+
- **Redis**: 5.0+
- **Git**: 2.x+

### 1.2 克隆代码

```bash
# 克隆后端代码
git clone https://github.com/ccfos/nightingale.git
cd nightingale

# 克隆前端代码
git clone https://github.com/n9e/fe.git
```

### 1.3 后端开发环境

1. **安装依赖**
   ```bash
   cd nightingale
   go mod download
   ```

2. **配置数据库**
   ```bash
   # 创建数据库
   mysql -u root -p -e "CREATE DATABASE n9e CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
   
   # 导入初始化SQL
   mysql -u root -p n9e < docker/initsql/a-n9e.sql
   ```

3. **配置Redis**
   ```bash
   # 启动Redis
   redis-server
   ```

4. **修改配置文件**
   ```bash
   cp etc/server.conf etc/server.conf.local
   vim etc/server.conf.local
   ```
   
   修改数据库和Redis配置:
   ```toml
   [DB]
   DSN = "root:password@tcp(127.0.0.1:3306)/n9e?charset=utf8mb4&parseTime=True&loc=Local"
   
   [Redis]
   Address = "127.0.0.1:6379"
   Password = ""
   DB = 0
   ```

5. **启动后端服务**
   ```bash
   # 开发模式(不嵌入前端资源)
   go run cmd/center/main.go -configs etc
   ```

### 1.4 前端开发环境

1. **安装依赖**
   ```bash
   cd fe
   npm install
   ```

2. **配置代理**
   
   修改 `vite.config.ts`:
   ```typescript
   export default defineConfig({
       server: {
           port: 8765,
           proxy: {
               '/api': {
                   target: 'http://localhost:8765',
                   changeOrigin: true,
               },
           },
       },
   });
   ```

3. **启动开发服务器**
   ```bash
   npm run dev
   ```

4. **访问应用**
   
   打开浏览器访问: http://localhost:8765
   
   默认账号: root / root.2020

## 2. 后端二次开发

### 2.1 添加新的API接口

#### 2.1.1 定义数据模型

在 `models/` 目录下创建新的模型文件:

```go
// models/custom_model.go
package models

import (
    "github.com/ccfos/nightingale/v6/pkg/ctx"
)

type CustomModel struct {
    Id       int64  `json:"id" gorm:"primaryKey"`
    Name     string `json:"name"`
    Value    string `json:"value"`
    CreateAt int64  `json:"create_at"`
    UpdateAt int64  `json:"update_at"`
}

func (c *CustomModel) TableName() string {
    return "custom_model"
}

// 创建
func (c *CustomModel) Create(ctx *ctx.Context) error {
    return Insert(ctx, c)
}

// 更新
func (c *CustomModel) Update(ctx *ctx.Context) error {
    return DB(ctx).Model(c).Updates(c).Error
}

// 删除
func (c *CustomModel) Delete(ctx *ctx.Context) error {
    return DB(ctx).Delete(c).Error
}

// 查询
func CustomModelGets(ctx *ctx.Context, where string, args ...interface{}) ([]*CustomModel, error) {
    var lst []*CustomModel
    err := DB(ctx).Where(where, args...).Find(&lst).Error
    return lst, err
}
```

#### 2.1.2 创建数据库迁移

在 `models/migrate/` 目录下添加迁移:

```go
// models/migrate/custom.go
package migrate

import "gorm.io/gorm"

func MigrateCustomModel(db *gorm.DB) error {
    return db.AutoMigrate(
        &models.CustomModel{},
    )
}
```

在 `models/migrate/migrate.go` 中调用:

```go
func Migrate(db *gorm.DB) {
    // ... 现有迁移
    MigrateCustomModel(db)
}
```

#### 2.1.3 添加路由处理器

在 `center/router/` 目录下创建路由文件:

```go
// center/router/router_custom.go
package router

import (
    "github.com/ccfos/nightingale/v6/models"
    "github.com/gin-gonic/gin"
    "github.com/toolkits/pkg/ginx"
)

// 获取列表
func (rt *Router) customModelGets(c *gin.Context) {
    lst, err := models.CustomModelGets(rt.Ctx, "")
    ginx.NewRender(c).Data(lst, err)
}

// 创建
func (rt *Router) customModelAdd(c *gin.Context) {
    var obj models.CustomModel
    ginx.BindJSON(c, &obj)
    
    obj.CreateAt = time.Now().Unix()
    obj.UpdateAt = time.Now().Unix()
    
    ginx.NewRender(c).Message(obj.Create(rt.Ctx))
}

// 更新
func (rt *Router) customModelPut(c *gin.Context) {
    var obj models.CustomModel
    ginx.BindJSON(c, &obj)
    
    obj.UpdateAt = time.Now().Unix()
    
    ginx.NewRender(c).Message(obj.Update(rt.Ctx))
}

// 删除
func (rt *Router) customModelDel(c *gin.Context) {
    var f idsForm
    ginx.BindJSON(c, &f)
    
    for _, id := range f.Ids {
        obj := &models.CustomModel{Id: id}
        obj.Delete(rt.Ctx)
    }
    
    ginx.NewRender(c).Message(nil)
}
```

#### 2.1.4 注册路由

在 `center/router/router.go` 的 `Config` 方法中添加路由:

```go
func (rt *Router) Config(r *gin.Engine) {
    // ... 现有路由
    
    pages := r.Group("/api/n9e")
    {
        // 自定义路由
        pages.GET("/custom-models", rt.auth(), rt.user(), rt.customModelGets)
        pages.POST("/custom-models", rt.auth(), rt.user(), rt.customModelAdd)
        pages.PUT("/custom-model/:id", rt.auth(), rt.user(), rt.customModelPut)
        pages.DELETE("/custom-models", rt.auth(), rt.user(), rt.customModelDel)
    }
}
```

### 2.2 添加新的数据源支持

#### 2.2.1 实现Querier接口

在 `datasource/` 目录下创建新的数据源实现:

```go
// datasource/custom/custom.go
package custom

import (
    "context"
    "github.com/ccfos/nightingale/v6/datasource"
)

type CustomDatasource struct {
    client *CustomClient
}

func NewCustomDatasource(settings map[string]interface{}) (*CustomDatasource, error) {
    client, err := NewCustomClient(settings)
    if err != nil {
        return nil, err
    }
    
    return &CustomDatasource{
        client: client,
    }, nil
}

func (c *CustomDatasource) QueryData(ctx context.Context, req datasource.QueryRequest) (datasource.QueryResponse, error) {
    // 实现查询逻辑
    results := make([]datasource.QueryResult, 0)
    
    for _, query := range req.Queries {
        result, err := c.executeQuery(ctx, query)
        if err != nil {
            return datasource.QueryResponse{}, err
        }
        results = append(results, result)
    }
    
    return datasource.QueryResponse{
        Results: results,
    }, nil
}

func (c *CustomDatasource) executeQuery(ctx context.Context, query datasource.Query) (datasource.QueryResult, error) {
    // 执行具体查询
    data, err := c.client.Query(query.Expr, query.Start, query.End)
    if err != nil {
        return datasource.QueryResult{}, err
    }
    
    return datasource.QueryResult{
        RefId:  query.RefId,
        Series: convertToSeries(data),
    }, nil
}
```

#### 2.2.2 注册数据源

在 `datasource/init.go` 中注册:

```go
func init() {
    RegisterDatasource("custom", func(settings map[string]interface{}) (Querier, error) {
        return custom.NewCustomDatasource(settings)
    })
}
```

### 2.3 添加新的通知渠道

#### 2.3.1 实现Sender接口

在 `alert/sender/` 目录下创建新的发送器:

```go
// alert/sender/custom_sender.go
package sender

import (
    "context"
    "github.com/ccfos/nightingale/v6/models"
)

type CustomSender struct {
    config CustomConfig
}

type CustomConfig struct {
    Url    string `json:"url"`
    Token  string `json:"token"`
}

func NewCustomSender(config interface{}) (*CustomSender, error) {
    cfg := CustomConfig{}
    // 解析配置
    
    return &CustomSender{
        config: cfg,
    }, nil
}

func (s *CustomSender) Send(ctx context.Context, event *models.AlertCurEvent) error {
    // 构造消息
    message := buildMessage(event)
    
    // 发送消息
    return s.sendMessage(message)
}

func (s *CustomSender) sendMessage(message string) error {
    // 实现发送逻辑
    return nil
}

func buildMessage(event *models.AlertCurEvent) string {
    // 构造消息内容
    return ""
}
```

#### 2.3.2 注册发送器

在 `alert/sender/sender.go` 中注册:

```go
func init() {
    RegisterSender("custom", func(config interface{}) (Sender, error) {
        return NewCustomSender(config)
    })
}
```

### 2.4 添加事件处理器

#### 2.4.1 实现Processor接口

在 `alert/pipeline/` 目录下创建处理器:

```go
// alert/pipeline/custom_processor.go
package pipeline

import (
    "context"
    "github.com/ccfos/nightingale/v6/models"
)

type CustomProcessor struct {
    config CustomProcessorConfig
}

type CustomProcessorConfig struct {
    Field string `json:"field"`
    Value string `json:"value"`
}

func NewCustomProcessor(config interface{}) (*CustomProcessor, error) {
    cfg := CustomProcessorConfig{}
    // 解析配置
    
    return &CustomProcessor{
        config: cfg,
    }, nil
}

func (p *CustomProcessor) Process(ctx context.Context, event *models.AlertCurEvent) error {
    // 处理事件
    // 例如: 添加标签、修改字段等
    
    return nil
}
```

#### 2.4.2 注册处理器

在 `alert/pipeline/pipeline.go` 中注册:

```go
func init() {
    RegisterProcessor("custom", func(config interface{}) (Processor, error) {
        return NewCustomProcessor(config)
    })
}
```

## 3. 前端二次开发

### 3.1 添加新页面

#### 3.1.1 创建页面组件

在 `src/pages/` 目录下创建新页面:

```typescript
// src/pages/customPage/index.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message } from 'antd';
import { getCustomModels, createCustomModel, updateCustomModel, deleteCustomModels } from '@/services/custom';

const CustomPage: React.FC = () => {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(false);
    const [visible, setVisible] = useState(false);
    const [editingRecord, setEditingRecord] = useState(null);
    const [form] = Form.useForm();
    
    useEffect(() => {
        fetchData();
    }, []);
    
    const fetchData = async () => {
        setLoading(true);
        try {
            const res = await getCustomModels();
            setData(res.dat || []);
        } catch (error) {
            message.error('获取数据失败');
        } finally {
            setLoading(false);
        }
    };
    
    const handleAdd = () => {
        setEditingRecord(null);
        form.resetFields();
        setVisible(true);
    };
    
    const handleEdit = (record) => {
        setEditingRecord(record);
        form.setFieldsValue(record);
        setVisible(true);
    };
    
    const handleDelete = async (id) => {
        try {
            await deleteCustomModels({ ids: [id] });
            message.success('删除成功');
            fetchData();
        } catch (error) {
            message.error('删除失败');
        }
    };
    
    const handleSubmit = async (values) => {
        try {
            if (editingRecord) {
                await updateCustomModel(editingRecord.id, values);
                message.success('更新成功');
            } else {
                await createCustomModel(values);
                message.success('创建成功');
            }
            setVisible(false);
            fetchData();
        } catch (error) {
            message.error('操作失败');
        }
    };
    
    const columns = [
        { title: 'ID', dataIndex: 'id', key: 'id' },
        { title: '名称', dataIndex: 'name', key: 'name' },
        { title: '值', dataIndex: 'value', key: 'value' },
        {
            title: '操作',
            key: 'action',
            render: (_, record) => (
                <>
                    <Button type="link" onClick={() => handleEdit(record)}>编辑</Button>
                    <Button type="link" danger onClick={() => handleDelete(record.id)}>删除</Button>
                </>
            ),
        },
    ];
    
    return (
        <div>
            <div style={{ marginBottom: 16 }}>
                <Button type="primary" onClick={handleAdd}>新建</Button>
            </div>
            
            <Table
                dataSource={data}
                columns={columns}
                loading={loading}
                rowKey="id"
            />
            
            <Modal
                title={editingRecord ? '编辑' : '新建'}
                visible={visible}
                onCancel={() => setVisible(false)}
                onOk={() => form.submit()}
            >
                <Form form={form} onFinish={handleSubmit}>
                    <Form.Item name="name" label="名称" rules={[{ required: true }]}>
                        <Input />
                    </Form.Item>
                    <Form.Item name="value" label="值" rules={[{ required: true }]}>
                        <Input />
                    </Form.Item>
                </Form>
            </Modal>
        </div>
    );
};

export default CustomPage;
```

#### 3.1.2 添加API服务

在 `src/services/` 目录下创建服务文件:

```typescript
// src/services/custom.ts
import request from '@/utils/request';

export function getCustomModels() {
    return request('/api/n9e/custom-models', {
        method: 'GET',
    });
}

export function createCustomModel(data: any) {
    return request('/api/n9e/custom-models', {
        method: 'POST',
        body: JSON.stringify(data),
    });
}

export function updateCustomModel(id: number, data: any) {
    return request(`/api/n9e/custom-model/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
    });
}

export function deleteCustomModels(data: { ids: number[] }) {
    return request('/api/n9e/custom-models', {
        method: 'DELETE',
        body: JSON.stringify(data),
    });
}
```

#### 3.1.3 添加路由

在 `src/routers/index.tsx` 中添加路由:

```typescript
import CustomPage from '@/pages/customPage';

// 在Switch中添加
<Route exact path='/custom-page' component={CustomPage} />
```

#### 3.1.4 添加菜单

在侧边菜单配置中添加菜单项:

```typescript
// 在菜单配置中添加
{
    key: '/custom-page',
    icon: <SettingOutlined />,
    label: '自定义页面',
}
```

### 3.2 添加新组件

#### 3.2.1 创建组件

在 `src/components/` 目录下创建组件:

```typescript
// src/components/CustomComponent/index.tsx
import React from 'react';
import './index.less';

interface CustomComponentProps {
    title?: string;
    data?: any[];
    onItemClick?: (item: any) => void;
}

const CustomComponent: React.FC<CustomComponentProps> = ({ title, data, onItemClick }) => {
    return (
        <div className="custom-component">
            {title && <h3>{title}</h3>}
            <ul>
                {data?.map((item, index) => (
                    <li key={index} onClick={() => onItemClick?.(item)}>
                        {item.name}
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default CustomComponent;
```

#### 3.2.2 添加样式

```less
// src/components/CustomComponent/index.less
.custom-component {
    padding: 16px;
    background: #fff;
    border-radius: 4px;
    
    h3 {
        margin-bottom: 12px;
        font-size: 16px;
        font-weight: 500;
    }
    
    ul {
        list-style: none;
        padding: 0;
        margin: 0;
        
        li {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.3s;
            
            &:hover {
                background: #f5f5f5;
            }
        }
    }
}
```

### 3.3 添加自定义Hook

```typescript
// src/hooks/useCustomData.ts
import { useState, useEffect } from 'react';
import { getCustomModels } from '@/services/custom';

export function useCustomData() {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    
    const fetchData = async () => {
        setLoading(true);
        setError(null);
        try {
            const res = await getCustomModels();
            setData(res.dat || []);
        } catch (err) {
            setError(err);
        } finally {
            setLoading(false);
        }
    };
    
    useEffect(() => {
        fetchData();
    }, []);
    
    return { data, loading, error, refetch: fetchData };
}

// 使用
const { data, loading, error, refetch } = useCustomData();
```

### 3.4 国际化支持

#### 3.4.1 添加翻译文件

```json
// src/locales/zh_CN/custom.json
{
    "custom.page.title": "自定义页面",
    "custom.table.name": "名称",
    "custom.table.value": "值",
    "custom.button.add": "新建",
    "custom.button.edit": "编辑",
    "custom.button.delete": "删除",
    "custom.message.success": "操作成功",
    "custom.message.error": "操作失败"
}

// src/locales/en_US/custom.json
{
    "custom.page.title": "Custom Page",
    "custom.table.name": "Name",
    "custom.table.value": "Value",
    "custom.button.add": "Add",
    "custom.button.edit": "Edit",
    "custom.button.delete": "Delete",
    "custom.message.success": "Success",
    "custom.message.error": "Failed"
}
```

#### 3.4.2 使用翻译

```typescript
import { useTranslation } from 'react-i18next';

const CustomPage: React.FC = () => {
    const { t } = useTranslation('custom');
    
    return (
        <div>
            <h1>{t('custom.page.title')}</h1>
            <Button>{t('custom.button.add')}</Button>
        </div>
    );
};
```

## 4. 插件开发

### 4.1 创建插件

```bash
# 在plugins目录下创建插件
mkdir -p plugins/my-plugin/src
cd plugins/my-plugin
```

### 4.2 插件结构

```
my-plugin/
├── package.json
├── index.ts              # 插件入口
├── routes.tsx            # 路由配置
└── src/
    ├── pages/            # 页面组件
    ├── components/       # 组件
    └── services/         # API服务
```

### 4.3 插件入口

```typescript
// plugins/my-plugin/index.ts
export default {
    name: 'my-plugin',
    version: '1.0.0',
    routes: [
        {
            path: '/my-plugin',
            component: () => import('./src/pages/Index'),
        },
    ],
    menu: [
        {
            key: '/my-plugin',
            label: '我的插件',
            icon: 'PluginOutlined',
        },
    ],
};
```

## 5. 测试

### 5.1 后端测试

```go
// models/custom_model_test.go
package models

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestCustomModel(t *testing.T) {
    // 初始化测试数据库
    db := setupTestDB()
    ctx := &ctx.Context{DB: db}
    
    // 测试创建
    model := &CustomModel{
        Name:  "test",
        Value: "value",
    }
    err := model.Create(ctx)
    assert.NoError(t, err)
    assert.NotZero(t, model.Id)
    
    // 测试查询
    models, err := CustomModelGets(ctx, "name = ?", "test")
    assert.NoError(t, err)
    assert.Len(t, models, 1)
    
    // 测试更新
    model.Value = "new value"
    err = model.Update(ctx)
    assert.NoError(t, err)
    
    // 测试删除
    err = model.Delete(ctx)
    assert.NoError(t, err)
}
```

### 5.2 前端测试

```typescript
// src/pages/customPage/index.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import CustomPage from './index';

test('renders custom page', () => {
    render(<CustomPage />);
    const button = screen.getByText('新建');
    expect(button).toBeInTheDocument();
});

test('opens modal on add button click', () => {
    render(<CustomPage />);
    const button = screen.getByText('新建');
    fireEvent.click(button);
    const modal = screen.getByRole('dialog');
    expect(modal).toBeInTheDocument();
});
```

## 6. 调试技巧

### 6.1 后端调试

1. **使用Delve调试器**
   ```bash
   # 安装delve
   go install github.com/go-delve/delve/cmd/dlv@latest
   
   # 启动调试
   dlv debug cmd/center/main.go -- -configs etc
   ```

2. **日志调试**
   ```go
   import "github.com/toolkits/pkg/logger"
   
   logger.Debug("debug message", "key", "value")
   logger.Info("info message")
   logger.Error("error message", "error", err)
   ```

### 6.2 前端调试

1. **使用React DevTools**
   - 安装浏览器扩展
   - 查看组件树和Props

2. **使用Redux DevTools**
   - 查看状态变化
   - 时间旅行调试

3. **Console调试**
   ```typescript
   console.log('data:', data);
   console.table(data);
   debugger; // 设置断点
   ```

## 7. 性能优化

### 7.1 后端优化

1. **数据库查询优化**
   - 添加索引
   - 使用预加载
   - 避免N+1查询

2. **缓存优化**
   - 使用内存缓存
   - 使用Redis缓存
   - 设置合理的过期时间

3. **并发优化**
   - 使用goroutine
   - 使用channel
   - 使用sync.Pool

### 7.2 前端优化

1. **代码分割**
   - 路由级别分割
   - 组件级别分割

2. **懒加载**
   - 图片懒加载
   - 组件懒加载

3. **缓存优化**
   - HTTP缓存
   - 本地存储缓存

## 8. 部署

### 8.1 后端部署

```bash
# 构建
make build

# 运行
./n9e -configs etc
```

### 8.2 前端部署

```bash
# 构建
npm run build

# 部署到nginx
cp -r dist/* /usr/share/nginx/html/
```

### 8.3 Docker部署

```dockerfile
# Dockerfile
FROM golang:1.24 AS backend-builder
WORKDIR /app
COPY nightingale/ .
RUN make build

FROM node:16 AS frontend-builder
WORKDIR /app
COPY fe/ .
RUN npm install && npm run build

FROM ubuntu:22.04
COPY --from=backend-builder /app/n9e /usr/local/bin/
COPY --from=frontend-builder /app/dist /usr/share/nginx/html/
CMD ["/usr/local/bin/n9e", "-configs", "/etc/n9e"]
```

## 9. 最佳实践

### 9.1 代码规范

- 遵循Go代码规范
- 遵循React代码规范
- 使用ESLint和Prettier
- 编写单元测试

### 9.2 Git工作流

- 使用feature分支开发
- 提交前进行代码审查
- 编写清晰的commit message

### 9.3 文档编写

- 编写API文档
- 编写使用文档
- 编写开发文档

## 10. 常见问题

### 10.1 后端常见问题

**Q: 数据库连接失败**
A: 检查数据库配置和网络连接

**Q: Redis连接失败**
A: 检查Redis配置和服务状态

**Q: 编译失败**
A: 检查Go版本和依赖

### 10.2 前端常见问题

**Q: npm install失败**
A: 清除缓存后重试: `npm cache clean --force`

**Q: 页面白屏**
A: 检查浏览器控制台错误

**Q: API请求失败**
A: 检查代理配置和后端服务状态

## 11. 参考资源

- [官方文档](https://flashcat.cloud/docs/)
- [GitHub仓库](https://github.com/ccfos/nightingale)
- [社区论坛](https://github.com/ccfos/nightingale/discussions)
- [问题反馈](https://github.com/ccfos/nightingale/issues)
