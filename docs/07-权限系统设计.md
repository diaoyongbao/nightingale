# Nightingale 权限系统设计文档

## 概述

Nightingale 采用基于角色的访问控制(RBAC)系统,结合了数据库权限配置和前端菜单过滤机制。本文档详细说明了权限系统的设计原理、实现细节以及在二次开发中的注意事项。

## 核心概念

### 1. 角色(Role)

系统内置三种角色:
- **Admin**: 管理员角色,拥有所有权限
- **Standard**: 标准用户角色,拥有大部分功能权限
- **Guest**: 访客角色,只读权限

### 2. 权限点(Operation)

权限点是系统中可执行操作的标识符,通常对应前端路由路径,例如:
- `/metric/explorer` - 指标查询权限
- `/alert-rules` - 告警规则查看权限
- `/alert-rules/add` - 告警规则添加权限
- `/dbm` - 数据库管理查看权限

### 3. 权限配置(builtInOps)

所有可用的权限点定义在 `center/cconf/ops.go` 的 `builtInOps` 常量中,采用 YAML 格式:

```yaml
ops:
- name: dbm
  cname: Database Management
  ops:
    - name: /dbm
      cname: Database Management - View
    - name: /dbm/write
      cname: Database Management - Write
```

## 权限系统架构

### 后端权限管理

#### 1. 数据库表结构

**role 表**: 存储角色信息
```sql
CREATE TABLE `role` (
    `id` bigint unsigned not null auto_increment,
    `name` varchar(191) not null default '',
    `note` varchar(255) not null default '',
    PRIMARY KEY (`id`),
    UNIQUE KEY (`name`)
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;
```

**role_operation 表**: 存储角色与权限的映射关系
```sql
CREATE TABLE `role_operation`(
    `id` bigint unsigned not null auto_increment,
    `role_name` varchar(128) not null,
    `operation` varchar(191) not null,
    KEY (`role_name`),
    KEY (`operation`),
    PRIMARY KEY(`id`)
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;
```

#### 2. Admin 角色的特殊处理

**重要**: Admin 角色在数据库中**没有具体的权限记录**。

根据 `docker/initsql/a-n9e.sql` 中的注释:
```sql
-- Admin is special, who has no concrete operation but can do anything.
```

这意味着:
- Admin 角色不需要在 `role_operation` 表中插入权限记录
- 后端在权限检查时,Admin 角色会被特殊处理,拥有所有权限
- 前端需要通过其他机制来显示 Admin 专属菜单

#### 3. 权限初始化流程

1. **加载配置**: `center/center.go` 中调用 `cconf.LoadOpsYaml()` 和 `cconf.MergeOperationConf()`
2. **合并权限**: 将 `builtInOps` 中定义的权限与配置文件中的权限合并
3. **存储到内存**: 权限配置存储在 `cconf.Operations` 变量中

#### 4. 权限查询 API

**接口**: `GET /api/n9e/auth/perms`

**实现**: `center/router/router_role.go` 中的 `allPerms` 函数

```go
func (rt *Router) allPerms(c *gin.Context) {
    roles, err := models.RoleGetsAll(rt.Ctx)
    ginx.Dangerous(err)
    m := make(map[string][]string)
    for _, r := range roles {
        lst, err := models.OperationsOfRole(rt.Ctx, strings.Fields(r.Name))
        if err != nil {
            continue
        }
        m[r.Name] = lst
    }
    ginx.NewRender(c).Data(m, err)
}
```

**返回格式**:
```json
{
  "dat": {
    "Admin": ["/alert-cur-events", "/alert-rules", ...],
    "Standard": ["/metric/explorer", "/dashboards", ...],
    "Guest": ["/metric/explorer", "/help/version"]
  },
  "err": ""
}
```

### 前端权限管理

#### 1. 权限数据获取

在 `App.tsx` 中,应用启动时获取权限:

```typescript
const { dat: perms } = await getMenuPerm();
const { dat: profile } = await GetProfile();

setCommonState((state) => ({
  ...state,
  perms,  // 权限列表
  profile, // 用户信息(包含 roles)
}));
```

#### 2. 菜单过滤机制

菜单过滤在 `components/SideMenu/index.tsx` 中实现,支持两种过滤方式:

##### 方式 1: 基于权限点(perms)

适用于大多数菜单项:

```typescript
return perms?.includes(calcUrlPath(child.key)) ? child : null;
```

##### 方式 2: 基于角色(role)

适用于 Admin 专属菜单:

```typescript
// 菜单配置
{
  key: 'dbm',
  label: 'menu.dbm',
  role: ['Admin'],  // 指定只有 Admin 角色可见
  type: 'tabs',
  children: [...]
}

// 过滤逻辑
if (child.role && child.role.length > 0) {
  const hasRole = child.role.some((role) => userRoles.includes(role));
  if (!hasRole) {
    return null;
  }
}
```

#### 3. 完整的菜单过滤逻辑

```typescript
useEffect(() => {
  const userRoles = profile?.roles || [];
  const filteredMenus = menuList
    .map((menu) => {
      const filteredChildren = menu.children
        .map((child) => {
          // 1. 检查 role 属性
          if (child.role && child.role.length > 0) {
            const hasRole = child.role.some((role) => userRoles.includes(role));
            if (!hasRole) {
              return null;
            }
          }
          
          // 2. 处理 tabs 类型菜单
          if (child.type === 'tabs' && child.children) {
            const filteredTabs = child.children.filter((tab) => {
              if (tab.role && tab.role.length > 0) {
                return tab.role.some((role) => userRoles.includes(role));
              }
              return perms?.includes(tab.key);
            });
            if (filteredTabs.length > 0) {
              return { ...child, children: filteredTabs };
            }
            return null;
          }
          
          // 3. 检查权限点
          return perms?.includes(calcUrlPath(child.key)) ? child : null;
        })
        .filter(Boolean);

      if (filteredChildren.length > 0) {
        return { ...menu, children: filteredChildren };
      }
      return null;
    })
    .filter(Boolean) as MenuItem[];

  setMenus(filteredMenus);
}, [i18n.language, embeddedProductMenu, profile]);
```

## 二次开发指南

### 添加新的权限点

#### 1. 在后端定义权限

编辑 `center/cconf/ops.go`,在 `builtInOps` 中添加:

```yaml
- name: MyFeature
  cname: My Feature
  ops:
    - name: /my-feature
      cname: My Feature - View
    - name: /my-feature/add
      cname: My Feature - Add
```

#### 2. 在路由中使用权限中间件

编辑 `center/router/router.go`:

```go
pages.GET("/my-feature", rt.perm("/my-feature"), rt.myFeatureHandler)
pages.POST("/my-feature", rt.perm("/my-feature/add"), rt.myFeatureAddHandler)
```

#### 3. 配置前端菜单

##### 方式 A: 使用权限点过滤(推荐用于 Standard 角色)

编辑 `fe/src/components/SideMenu/menu.tsx`:

```typescript
{
  key: '/my-feature',
  label: 'menu.my_feature',
  // 不需要 role 属性,会自动根据 perms 过滤
}
```

然后在数据库中为角色添加权限:

```sql
INSERT INTO role_operation(role_name, operation) VALUES('Standard', '/my-feature');
INSERT INTO role_operation(role_name, operation) VALUES('Admin', '/my-feature');
```

##### 方式 B: 使用角色过滤(推荐用于 Admin 专属功能)

编辑 `fe/src/components/SideMenu/menu.tsx`:

```typescript
{
  key: '/my-feature',
  label: 'menu.my_feature',
  role: ['Admin'],  // 只有 Admin 可见,不依赖数据库权限
}
```

#### 4. 添加国际化

编辑 `fe/src/components/SideMenu/locale/zh_CN.ts`:

```typescript
export default {
  menu: {
    my_feature: '我的功能',
  },
};
```

### 权限检查最佳实践

#### 后端权限检查

1. **路由级别**: 使用 `perm()` 中间件
```go
pages.GET("/my-feature", rt.perm("/my-feature"), handler)
```

2. **函数级别**: 手动检查权限
```go
func (rt *Router) myHandler(c *gin.Context) {
    user := c.MustGet("user").(*models.User)
    if !user.HasPerm("/my-feature") {
        ginx.Bomb(http.StatusForbidden, "no permission")
        return
    }
    // ...
}
```

#### 前端权限检查

1. **菜单级别**: 在 `menu.tsx` 中配置
2. **页面级别**: 使用 `useContext(CommonStateContext)` 获取 `perms`
```typescript
const { perms } = useContext(CommonStateContext);
if (!perms?.includes('/my-feature')) {
  return <NoPermission />;
}
```

3. **按钮级别**: 条件渲染
```typescript
{perms?.includes('/my-feature/add') && (
  <Button onClick={handleAdd}>添加</Button>
)}
```

## 常见问题

### Q1: 为什么 Admin 角色看不到某些菜单?

**原因**: 菜单配置中没有使用 `role` 属性,而是依赖 `perms`,但 Admin 角色在数据库中没有权限记录。

**解决方案**: 为 Admin 专属菜单添加 `role: ['Admin']` 属性。

### Q2: 如何让某个功能只对 Admin 开放?

**方案 1**: 使用 `role` 属性(推荐)
```typescript
{
  key: '/admin-only-feature',
  label: 'menu.admin_only',
  role: ['Admin'],
}
```

**方案 2**: 在数据库中只为 Admin 添加权限
```sql
INSERT INTO role_operation(role_name, operation) VALUES('Admin', '/admin-only-feature');
```

### Q3: 删除数据库后权限丢失怎么办?

**问题**: 删除 `n9e.db` 会清空所有权限配置。

**解决方案**:
1. 使用 `role` 属性的菜单不受影响
2. 依赖数据库权限的菜单需要重新配置
3. 建议备份数据库或使用初始化 SQL 脚本

### Q4: 如何调试权限问题?

1. **检查权限 API**: 访问 `/api/n9e/auth/perms` 查看当前用户的权限列表
2. **检查用户角色**: 查看 `users` 表的 `roles` 字段
3. **检查权限配置**: 查看 `role_operation` 表
4. **检查前端过滤**: 在浏览器控制台查看 `perms` 和 `profile.roles`

## 总结

Nightingale 的权限系统设计灵活,支持两种权限控制方式:

1. **基于权限点(perms)**: 适用于需要细粒度控制的功能
2. **基于角色(role)**: 适用于 Admin 专属功能,简化配置

在二次开发时,建议:
- Admin 专属功能使用 `role` 属性
- 多角色共享功能使用权限点配置
- 保持后端权限定义与前端菜单配置的一致性
