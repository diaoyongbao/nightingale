# 夜莺监控后端架构详解

## 1. 整体架构

### 1.1 分层架构

```
┌─────────────────────────────────────────┐
│           HTTP Layer (Gin)              │
│  - Router                               │
│  - Middleware (Auth, CORS, etc)         │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│         Business Logic Layer            │
│  - Center (Web服务)                     │
│  - Alert (告警引擎)                     │
│  - PushGW (数据网关)                    │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│          Data Access Layer              │
│  - Models (GORM)                        │
│  - Memsto (内存缓存)                    │
│  - Storage (数据库/Redis)               │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│         External Services               │
│  - MySQL/PostgreSQL                     │
│  - Redis                                │
│  - Prometheus/VictoriaMetrics           │
│  - Elasticsearch/Loki                   │
└─────────────────────────────────────────┘
```

### 1.2 模块依赖关系

```
cmd/center/main.go
    └─► center/center.go (Initialize)
            ├─► storage.New() - 数据库连接
            ├─► memsto.* - 各种缓存初始化
            │   ├─► AlertRuleCache
            │   ├─► AlertMuteCache
            │   ├─► DatasourceCache
            │   ├─► UserCache
            │   └─► ...
            ├─► alert.Start() - 启动告警引擎
            ├─► router.Config() - 配置路由
            └─► httpx.Init() - 启动HTTP服务
```

## 2. 核心模块详解

### 2.1 Center模块 (中心服务)

**职责**: 提供Web界面和API服务,管理配置和元数据

**核心组件**:

1. **Router** (`center/router/router.go`)
   - 定义所有HTTP路由
   - 配置中间件(认证、权限、日志等)
   - 路由分类:
     - 页面API: `/api/n9e/*`
     - 服务API: `/v1/n9e/*`
     - Agent API: `/v1/n9e/heartbeat`

2. **认证中间件** (`center/router/router_mw.go`)
   ```go
   // 主要中间件
   - auth()          // JWT认证
   - user()          // 用户信息加载
   - admin()         // 管理员权限检查
   - perm()          // 操作权限检查
   - bgro()          // 业务组只读权限
   - bgrw()          // 业务组读写权限
   ```

3. **SSO支持** (`center/sso/`)
   - OAuth2
   - CAS
   - LDAP
   - 钉钉
   - 自定义SSO

4. **配置管理** (`center/cconf/`)
   - `conf.go`: 配置结构定义
   - `ops.go`: 操作权限配置
   - `metric.go`: 指标元数据配置
   - `plugin.go`: 插件配置

5. **集成管理** (`center/integration/`)
   - 内置监控模板
   - 告警规则模板
   - 仪表盘模板

### 2.2 Alert模块 (告警引擎)

**职责**: 告警规则评估、事件生成、告警分发

**核心组件**:

1. **规则评估** (`alert/eval/`)
   ```go
   // 评估流程
   1. 从缓存加载告警规则
   2. 根据规则类型选择评估器
   3. 查询数据源获取数据
   4. 执行告警判定逻辑
   5. 生成告警事件
   ```

2. **告警分发** (`alert/dispatch/`)
   ```go
   // 分发流程
   1. 接收告警事件
   2. 检查告警屏蔽规则
   3. 应用事件管道处理
   4. 匹配通知规则
   5. 发送到通知队列
   ```

3. **告警发送** (`alert/sender/`)
   - 支持的通知渠道:
     - Email
     - SMS
     - 钉钉
     - 飞书
     - 企业微信
     - Slack
     - Telegram
     - Webhook
     - 等20+种渠道

4. **事件管道** (`alert/pipeline/`)
   ```go
   // Pipeline处理器
   - Relabel: 标签重写
   - Filter: 事件过滤
   - Enrich: 事件增强
   - Transform: 数据转换
   ```

5. **告警命名** (`alert/naming/`)
   - 告警事件标题生成
   - 告警事件描述生成
   - 支持模板变量

### 2.3 PushGW模块 (推送网关)

**职责**: 接收监控数据,转发到时序库

**核心组件**:

1. **数据接收** (`pushgw/router/`)
   - Remote Write协议
   - OpenTSDB协议
   - Datadog协议
   - Falcon协议

2. **数据转发** (`pushgw/writer/`)
   ```go
   // Writer接口
   type Writer interface {
       Write(items []*prompb.TimeSeries) error
   }
   
   // 支持的后端
   - Prometheus
   - VictoriaMetrics
   - M3DB
   - TDEngine
   ```

3. **标识管理** (`pushgw/idents/`)
   - 监控对象标识管理
   - 自动注册和更新
   - 心跳检测

### 2.4 Models模块 (数据模型)

**核心模型**:

1. **AlertRule** (`models/alert_rule.go`)
   ```go
   type AlertRule struct {
       Id                int64
       GroupId           int64              // 业务组ID
       Cate              string             // 规则类型
       DatasourceQueries []DatasourceQuery  // 数据源查询
       Name              string             // 规则名称
       PromQl            string             // PromQL查询
       RuleConfig        string             // 规则配置(JSON)
       Severity          int                // 告警级别
       NotifyRuleIds     []int64            // 通知规则ID
       CronPattern       string             // Cron表达式
       // ... 更多字段
   }
   ```

2. **AlertCurEvent** (`models/alert_cur_event.go`)
   ```go
   type AlertCurEvent struct {
       Id            int64
       RuleId        int64
       RuleName      string
       Severity      int
       Status        int    // 0:触发 1:恢复
       Tags          string // JSON格式
       TriggerTime   int64
       // ... 更多字段
   }
   ```

3. **Target** (`models/target.go`)
   ```go
   type Target struct {
       Id          int64
       Ident       string  // 唯一标识
       Note        string  // 备注
       Tags        string  // 标签
       UpdateAt    int64
       // ... 更多字段
   }
   ```

4. **Datasource** (`models/datasource.go`)
   ```go
   type Datasource struct {
       Id          int64
       Name        string
       PluginType  string  // prometheus, elasticsearch等
       Settings    string  // JSON配置
       IsDefault   bool
       // ... 更多字段
   }
   ```

### 2.5 Memsto模块 (内存缓存)

**职责**: 缓存热数据,减少数据库查询

**核心缓存**:

1. **AlertRuleCache**
   ```go
   // 缓存所有告警规则
   - 按业务组索引
   - 按数据源索引
   - 定期从数据库同步
   ```

2. **AlertMuteCache**
   ```go
   // 缓存告警屏蔽规则
   - 快速匹配屏蔽规则
   - 支持正则表达式
   ```

3. **DatasourceCache**
   ```go
   // 缓存数据源配置
   - 按类型分组
   - 提供快速查询
   ```

4. **UserCache & UserGroupCache**
   ```go
   // 缓存用户和用户组信息
   - 用于权限检查
   - 用于通知对象解析
   ```

5. **TargetCache**
   ```go
   // 缓存监控对象
   - 按标识索引
   - 按业务组索引
   - 支持标签查询
   ```

**同步机制**:

```go
// 定期同步
type SyncStats struct {
    sync.RWMutex
    stats map[string]*Stats
}

// 每个缓存独立同步
func (c *Cache) SyncLoop() {
    for {
        select {
        case <-time.After(syncInterval):
            c.Sync()
        }
    }
}
```

## 3. 数据流

### 3.1 监控数据流

```
Categraf/Agent
    │
    │ Remote Write
    ▼
PushGW (接收)
    │
    │ 写入
    ▼
Prometheus/VictoriaMetrics
    │
    │ 查询
    ▼
Alert Engine (评估)
    │
    │ 生成事件
    ▼
Alert Dispatcher (分发)
    │
    │ 发送通知
    ▼
Notification Channels
```

### 3.2 告警规则评估流程

```go
// 1. 加载规则
rules := alertRuleCache.GetRules()

// 2. 遍历规则
for _, rule := range rules {
    // 3. 查询数据
    data := promClient.Query(rule.PromQl)
    
    // 4. 评估
    if shouldAlert(data, rule) {
        // 5. 生成事件
        event := generateEvent(rule, data)
        
        // 6. 发送到分发器
        dispatcher.Dispatch(event)
    }
}
```

### 3.3 告警事件处理流程

```go
// 1. 接收事件
event := <-eventQueue

// 2. 检查屏蔽
if isMuted(event) {
    return
}

// 3. 应用Pipeline
event = applyPipeline(event)

// 4. 匹配通知规则
notifyRules := matchNotifyRules(event)

// 5. 发送通知
for _, rule := range notifyRules {
    sendNotification(event, rule)
}

// 6. 记录通知历史
saveNotificationRecord(event)
```

## 4. 数据库设计

### 4.1 核心表结构

1. **alert_rule** (告警规则)
   ```sql
   CREATE TABLE alert_rule (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       group_id BIGINT NOT NULL,
       cate VARCHAR(128),
       datasource_queries TEXT,
       name VARCHAR(255) NOT NULL,
       note TEXT,
       prom_ql TEXT,
       rule_config TEXT,
       severity INT,
       disabled INT DEFAULT 0,
       prom_eval_interval INT,
       notify_rule_ids JSON,
       cron_pattern VARCHAR(255),
       create_at BIGINT,
       create_by VARCHAR(64),
       update_at BIGINT,
       update_by VARCHAR(64),
       INDEX idx_group_id (group_id),
       INDEX idx_update_at (update_at)
   );
   ```

2. **alert_cur_event** (当前告警事件)
   ```sql
   CREATE TABLE alert_cur_event (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       rule_id BIGINT NOT NULL,
       rule_name VARCHAR(255),
       severity INT,
       status INT,
       tags TEXT,
       trigger_time BIGINT,
       trigger_value VARCHAR(255),
       target_ident VARCHAR(191),
       INDEX idx_rule_id (rule_id),
       INDEX idx_trigger_time (trigger_time),
       INDEX idx_target_ident (target_ident)
   );
   ```

3. **target** (监控对象)
   ```sql
   CREATE TABLE target (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       ident VARCHAR(191) UNIQUE NOT NULL,
       note VARCHAR(255),
       tags TEXT,
       update_at BIGINT,
       INDEX idx_update_at (update_at)
   );
   ```

4. **datasource** (数据源)
   ```sql
   CREATE TABLE datasource (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       name VARCHAR(191) UNIQUE NOT NULL,
       plugin_type VARCHAR(255),
       settings TEXT,
       status VARCHAR(255),
       is_default BOOLEAN,
       create_at BIGINT,
       update_at BIGINT
   );
   ```

### 4.2 关系设计

```
busi_group (业务组)
    │
    ├─► alert_rule (告警规则)
    │       │
    │       └─► alert_cur_event (当前事件)
    │       └─► alert_his_event (历史事件)
    │
    ├─► alert_mute (告警屏蔽)
    ├─► alert_subscribe (告警订阅)
    ├─► dashboard (仪表盘)
    └─► target_busi_group (监控对象关联)
            │
            └─► target (监控对象)

user (用户)
    │
    ├─► user_group_member (用户组成员)
    │       │
    │       └─► user_group (用户组)
    │
    └─► busi_group_member (业务组成员)
            │
            └─► busi_group (业务组)
```

## 5. 配置系统

### 5.1 配置文件结构

```toml
[Log]
Level = "INFO"
Dir = "logs"

[HTTP]
Host = "0.0.0.0"
Port = 8765
PrintAccessLog = false

[DB]
DSN = "root:password@tcp(127.0.0.1:3306)/n9e?charset=utf8mb4"
MaxIdleConns = 50
MaxOpenConns = 150

[Redis]
Address = "127.0.0.1:6379"
Password = ""
DB = 0

[Alert]
[Alert.Heartbeat]
IP = "127.0.0.1"
Interval = 1000

[Pushgw]
Enable = true
```

### 5.2 动态配置

通过 `configs` 表存储动态配置:

```go
// 配置读取
func ConfigsGet(ctx *ctx.Context, key string) (string, error)

// 配置写入
func ConfigsSet(ctx *ctx.Context, key, value string) error

// 常用配置项
- site_info: 站点信息
- smtp: 邮件配置
- ibex: 任务执行配置
- notify_channels: 通知渠道配置
```

## 6. 权限系统

### 6.1 权限模型

```
User (用户)
    │
    ├─► Role (角色)
    │       │
    │       └─► Operation (操作权限)
    │
    └─► BusiGroup (业务组)
            │
            └─► Permission (组内权限: Admin/Standard/Guest)
```

### 6.2 权限检查流程

```go
// 1. 检查用户是否登录
if !isAuthenticated(user) {
    return Unauthorized
}

// 2. 检查是否系统管理员
if user.IsAdmin() {
    return Allow
}

// 3. 检查操作权限
if !hasPermission(user, operation) {
    return Forbidden
}

// 4. 检查业务组权限
if !hasBusiGroupPermission(user, busiGroupId, permission) {
    return Forbidden
}

return Allow
```

### 6.3 操作权限配置

在 `etc/ops.yaml` 中定义:

```yaml
ops:
  - name: "/users"
    ops: ["GET", "POST", "PUT", "DELETE"]
  - name: "/alert-rules"
    ops: ["GET", "POST", "PUT", "DELETE"]
  - name: "/dashboards"
    ops: ["GET", "POST", "PUT", "DELETE"]
```

## 7. 性能优化

### 7.1 缓存策略

1. **内存缓存** (Memsto)
   - 告警规则: 全量缓存
   - 用户信息: 全量缓存
   - 数据源: 全量缓存
   - 监控对象: 全量缓存

2. **Redis缓存**
   - 会话信息
   - 临时数据
   - 分布式锁

### 7.2 数据库优化

1. **索引设计**
   - 主键索引
   - 外键索引
   - 查询字段索引
   - 复合索引

2. **查询优化**
   - 使用GORM预加载
   - 避免N+1查询
   - 分页查询

### 7.3 并发控制

```go
// 使用sync.RWMutex保护共享数据
type Cache struct {
    sync.RWMutex
    data map[string]interface{}
}

// 读操作
func (c *Cache) Get(key string) interface{} {
    c.RLock()
    defer c.RUnlock()
    return c.data[key]
}

// 写操作
func (c *Cache) Set(key string, value interface{}) {
    c.Lock()
    defer c.Unlock()
    c.data[key] = value
}
```

## 8. 扩展点

### 8.1 数据源扩展

实现 `datasource.Querier` 接口:

```go
type Querier interface {
    QueryData(ctx context.Context, req QueryRequest) (QueryResponse, error)
}
```

### 8.2 通知渠道扩展

实现 `sender.Sender` 接口:

```go
type Sender interface {
    Send(ctx context.Context, event *models.AlertCurEvent) error
}
```

### 8.3 事件处理器扩展

实现 `pipeline.Processor` 接口:

```go
type Processor interface {
    Process(ctx context.Context, event *models.AlertCurEvent) error
}
```

## 9. 监控和运维

### 9.1 健康检查

```go
// 心跳接口
POST /v1/n9e/heartbeat
{
    "ident": "server-01",
    "clock": 1234567890
}
```

### 9.2 指标暴露

通过 Prometheus 客户端暴露内部指标:

```go
// 请求计数
requestCounter := prometheus.NewCounterVec(...)

// 请求延迟
requestDuration := prometheus.NewHistogramVec(...)

// 告警规则数量
alertRuleGauge := prometheus.NewGauge(...)
```

### 9.3 日志管理

```go
// 使用toolkits/pkg/logger
logger.Info("message", "key", "value")
logger.Error("error message", "error", err)
logger.Debug("debug message")
```

## 10. 安全性

### 10.1 认证

- JWT Token认证
- Basic Auth认证
- SSO认证

### 10.2 授权

- 基于角色的访问控制(RBAC)
- 业务组级别权限控制
- 操作级别权限控制

### 10.3 数据加密

- 密码使用bcrypt加密
- 敏感配置支持加密存储
- HTTPS传输加密

### 10.4 防护措施

- SQL注入防护(GORM参数化查询)
- XSS防护(前端输入验证)
- CSRF防护(Token验证)
- 限流保护
